#01 算法入门概念
# 算法(Algorithm):一个计算过程，解决问题的方法
# 程序 = 数据结构 + 算法    数据结构 静态     算法 动态

#02 估计算法运行效率与时间复杂度
# 用什么方式体现算法运行的快慢？   (不能使用时间)
# for循环执行n次 n在算法里叫做问题的规模(问题的复杂度)
# 时间复杂度：用来评估算法运行效率的一个式子
print('Hello World')    # 注：时间复杂度定义为 O(1)   1个print 1就是一个单位 基本操作是1

n = input('请输出n:')

for i in range(n):       # 注：O(n)   运行n次
    print('Hello World')

for i in range(n):       # 注：O(n2)
    for j in range(n):
        print('Hello World')

for i in range(n):       # 注：O(n3)
    for j in range(n):
        for k in range(n):
            print('Hello World')

print('Hello World')        # 注：O(1)    打印1次和3次差距不大 没有上升到n这么大
print('Hello Python')       # 注：表示近似
print('Hello Algorithm')
#--------------------------
for i in range(n):           # 注：O(n2)  忽略 n 忽略小单位
    print('Hello World')    # 注：类比生活的问几个小时 不涉及分钟
    for j in range(n):
        print('Hello World')
#--------------------------
while n > 1:
    print(n)                # 注:问题规模少一半 但不能写n/2
    n = n // 2
# 时间复杂度记为O(log2n)或 O(logn)     # 注：以对数形式表示
# 把2省略掉，依据是计算机里面都是二进制的
# 当算法过程出现循环折半的时候， 复杂度式子中会出现logn
# 注：当算法出现循环减半的时候，就一定会出现logn (问题规模缩小一半)
# n=64 输出:                  2**6=64
# 64                          log2(64)=6
# 32
# 16
# 8
# 4
# 2

### 时间复杂度小节
# 时间复杂度是用来估计算法运行时间的一个式子（单位）。
# 一般来说，时间复杂度高的算法比复杂度低的算法慢。  # 注：为什么是一般来说，1因为和机器有关系，2因为和n有关系
# 常见的时间复杂度（按效率排序）
#       O(1)<O(logn)<O(n)<O(nlogn)<O(n**2)<O(n**2logn)<O(n**3)
# 理解：O(1) 只执行1次或几次
# <O(logn)<O(n) logn比n小  log64 < 6
# n < n方 < n立方
# O(n)<O(nlogn)<O(n**2)<O(n**2logn)<O(n**3)
# 复杂问题的时间复杂度 O(n!) O(2**n) O(n**n) …    n的阶层…… 非常难解决的问题

#可以把logn想成0.5n  (自己的理解)

#03 简单判断时间复杂度
### 如何简单快速地判断算法复杂度
# 快速判断算法复杂度（适用于绝大多数简单情况）：
#       确定问题规模n         # 注：循环次数 列表进行排序就是列表的长度
#       循环减半过程→logn    # 注：循环折半的情况
#       k层关于n的循环→n**k  # 注：几层循环就是n的几次方  列表长度的循环次数
# 复杂情况：根据算法执行过程判断

#04 空间复杂度
### 空间复杂度
# 空间复杂度：用来评估算法内存占用大小的式子
# 空间复杂度的表示方式与时间复杂度完全一样
#       算法使用了几个变量：O(1)          # 注：1个变量是0(1)   2个变量也是O(1)
#       算法使用了⻓度为n的一维列表：O(n)
#       算法使用了m行n列的二维列表：O(mn)    # 注：m*n     n行n列 n*n
# “空间换时间”   # 注：研究1个算法，时间比空间重要  (远远)    因为现在内存造价便宜了 让用户等待时间到短
    # 注：规则 空间换时间    所以有很多分布式允许  1个机器上运算的东西放到多个机器上运算

#注：跑起来看一看   涉及到n的问题，n不同，内存占用就不一样

#05 递归
#复习：递归
### 递归的两个特点：
#       调用自身
#       结束条件
#---------------------------------------------------------
def func1(x):   # 注：不是合法递归 因为没有结束条件 (死递归)
    print(x)    # 注：比如x=3进去，会无线循环下去
    func1(x-1)
#---------------------------------------------------------
def func2(x):   # 注：不是合法递归
    if x>0:     # 注：看似合法条件 但是最后是x+1
        print(x)    # 注：2,3,4,5……
        func2(x+1)
#---------------------------------------------------------
def func3(x):   # 注：合法递归
    if x>0:
        print(x)
        func3(x-1)
# 传进去x=3 会打印3 2 1
#---------------------------------------------------------
def func4(x):
    if x>0:
        func4(x-1)
        print(x)
# 传进去x=3 会打印1 2 3
#---------------------------------------------------------
# 可以用框表示函数的调用   这样好理解
# func3先是打印 后是递归    先小后大
# func4先递归   后打印      先大后小  最里层print 是 x=1 先打印

#06 汉诺塔问题
### 递归实例：汉诺塔问题
# 大梵天创造世界的时候做了三根金刚石柱子，在一根 柱子上从下往上按照大小顺序摞着64片⻩金圆盘。
# 大梵天命令婆罗门把圆盘从下面开始按大小顺序重新 摆放在另一根柱子上。
# 在小圆盘上不能放大圆盘，在三根柱子之间一次只能 移动一个圆盘。
# 64根柱子移动完毕之日，就是世界毁灭之时。

# 注：小圆盘只能放在大圆盘的上面 不能放在下面
#------------------------------------------------------------
### n=2时：
# 1.把小圆盘从A移动到B
# 2.把大圆盘从A移动到C
# 3.把小圆盘从B移动到C
#------------------------------------------------------------
### n个盘子时：                    # 注：把它看作是递归的过程
# 1.把n-1个圆盘从A经过C移动到B
# 2.把第n个圆盘从A移动到C
# 3.把n-1个小圆盘从B经过A移动到C
#------------------------------------------------------------
### 注：把它看作是递归的过程
#注：把上面 n - 1 个盘子看成整体
#注：把下面 1 个盘子看成1个部分
#n 个盘子时
# 1.把 n-1 个圆盘从A经过C移动到B    # 注：中间的过程 不管怎么经过C     第1、3步  移动 n-1个盘子
# 2.把第n个圆盘从A移动到C           # 注：最底下的盘子 从A移动到C      只有第2步 是移动一步的情况
# 3.把n-1个小圆盘从B经过A移动到C       # 注：第1、3步  移动 n-1个盘子

#注：它不是一个只能移动一个盘子的合法的步骤，但是它是一个比原问题规模小了1的同样的1个问题  (n-1)
#注：递归：第1步和第3步是原问题的递归的子问题 (比它规模更小的问题)
#-----------------------------------------------------------------------
#注：(n, a, b, c) --> 把n个盘子从a移动到c 中间的b是经过b 第3个参数是经过
#注：参数意义：n把几个盘子 a 从a，b 经过b，c 移动到c
def hanoi(n, a, b, c):  # 注：参数n 表示 n个盘子 ； a、b、c表示这3个参数表示这三个盘子的名字
    if n > 0:           # 注：递归终止条件是 n = 0 的时候  一步都不需要移动(没有盘子)
        # 注：第一步 (n-1, a, c, b) --> n-1个盘子 从a经过 b 移动到c
        hanoi(n-1, a, c, b) # 注：把n-1个盘子从A经过C移动到B    调用自己 n-1个盘子 从a经过b移动到c
        # print("#%d: moving from %s to %s." % (num, a, c))   # 注：第2步 最大的盘子 从a移动到c
        print("moving from %s to %s." % (a, c))
        hanoi(n-1, b, a, c) # 注：n-1个盘子 从 b 经过 a 移动到 c
#注：每次移动都只是柱子最上面那个
hanoi(3, 'A', 'B', 'C')
#结果为
# moving from A to C.
# moving from A to B.
# moving from C to B.
# moving from A to C.
# moving from B to A.
# moving from B to C.
# moving from A to C.

#注：理解
#当 n = 0 时 什么都不打印
#当 n = 1 时 打印 from a to c    只打印中间那句话 从a --> c  (理解时可以忽略中间b)
#当 n = 2 时 先把1个盘子从a-->b ，再把1个盘子从 a-->c, 再把 从b -->c
#当 n = 3 是 前面3步是2个盘子的问题 后面3步也是2个盘子的问题
#-----------------------------------------------------------------------
###假设n个盘子 移动需要 h(n)次
# 先需要h(n-1)步 + 1步 +h(n-1)步  h大概是2的n次方

# 汉诺塔移动次数的递推式：h(x)=2h(x-1)+1
# h(64)=18446744073709551615
# 假设婆罗⻔每秒钟搬一个盘子，则总共需要5800亿年


#07 顺序查找
###列表查找
# 什么是列表查找
# 顺序查找
# 二分查找

#查找
# 查找：在一些数据元素中，通过一定的方法找出与给定关键字相同的数据元素的过程。
# 列表查找（线性表查找）：从列表中查找指定元素 输入：列表、待查找元素
# 输出：元素下标（未找到元素时一般返回None或-1）    # 注：因为下标一般从0 开始 所以返回-1表示没有查到 或返回None
#
# 内置列表查找函数：index()

#注：列表查找是1个算法
#---------------------------------------------------------
### 顺序查找 (Linear Search)
# 顺序查找：也叫线性查找，从列表第一个元素开始，顺序进行搜索，直到找到元素或搜索到列表最后一个元素为止。
#注：就是从头走到尾  中间找到停掉 返回下标  或者走到最后一个 找不到了 返回-1或者None
# 时间复杂度：O(n)

# 示例：线性搜索/顺序查找
def Linear_search(li, val):     # 注：li列表 ；val待查找的元素
    for ind, v in enumerate(li):       # 注：因为要返回个下标 所以用 enumerate index和值都需要
        if v == val:    # 注：如果v == 我们要找的那个值 那就返回 它的index
            return ind
    else:   # 如果for循环结束后还没有找到 返回None
        return None
# 注：时间复杂度是 O(n)
#n 就是列表的长度
#第2步：没有循环减半的过程
#第3步：有1个跟n 相关的循环    所以时间复杂度是O(n)

#顺序查找是把列表从头到尾走了一遍 所以最多走n步  复杂度0(n)
def linear_search(data_set, value):
    for i in range(range(data_set)):
        if data_set[i] == value:
            return i
    return      # 理解为 默认返回None

#08 二分查找介绍
# 二分查找：又叫折半查找，从有序列表的初始候选区li[0:n]开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半。

#注：比如公司要选模特 身高必须175
#注：从头找 是顺序查找
#注：按大小个站好，量中间那个人的身高，假如是165，说明175的人在165后面
# 可以让左边所以人走了，量过的那个人 也可以走了 还剩大概50个人 再找50个人中间的
# 他是178 ， 所以178后面那些人又不要了，
# 还剩165 - 178之间的那些人，依次找中间的，每一次让整个人数缩小一半
# 剩下1个人如果都没有 说明整个都没有

#留在这里的人叫候选区(值可能出现在这里)
#-------------------------------------------------------------------------------
### 从列表中查找元素3：
# 1  2  3  4  5  6  7  8  9
# left        mid         right
#注：传入的是 列表和要找的元素3
#注：维护候选区  用2个变量  列表不要了  不能把不要的值扔掉
#注：初始时 left = 0 (指向第1个元素)       right = n-1 (指向最后1个元素)
#注：求中间的元素  (left + right) / 2  = mid	地板除
#判断中间元素5 和3 进行 比较 发现比3  大  候选区在左边
#注：如何维护候选区？： 让right到4这边来 (mid=5的左边1个)
#即 right = mid - 1  循环了 再计算新的 mid = (0 + 3) / 2 = 1 (下标计算) 结果 地板除
#发现 mid = 2 比 3 小  说明在mid 的右边
#所以 left = mid + 1  移动left 到 mid 右边
#注：left = 2 ;right = 3 (下标) （2 + 3） / 2 = 2  所以 mid 还是只想3 索引是2
#注：mid 索引是2 mid 和我们要查的元素一样了  那就终止算法 输出mid的值 3 (输出下标)

#注：可以理解为 2 和 6 中间的数 是 4  所以(2 + 6) / 2 = 4

#如果最后1步  mid的值不为3 为 4 ，  比想要的值3 大  那么 right = mid -1  候选区就没有值了

#left小于right 的时候 候选区有值
#left = rigth 的时候 也有值 就1个值
#left 如果大于 right 说明候选区没有值 ， 就结束算法  说明找不到了


#09 二分查找代码
def binary_search(li, val): # li 列表  val待查找的值
    left = 0
    right = len(li) - 1
    while left <= right:    # 注：循环条件 说明候选区有值
        mid = (left + right) // 2   # 注：中间值(下标) 是整除2
        if li[mid] == val:  # 注：== 找到的情况   每次对比都是对比的li[mid]
            return mid      # 注：返回下标 mid
        elif li[mid] > val:  # 注：代表 待查找的值val在 mid左边
            right = mid - 1  # 注：更新候选区了 这种情况就可以继续循环
        else:               # 注：第3种情况 li[mid] < val  待查找的值在mid右侧
            left = mid + 1   # 注：更新候选区  继续循环
    else:
        return None         # 注：如果找不到的情况 即不满足 left <= right 时

li = [1,2,3,4,5,6,7,8,9]
print(binary_search(li,3))       # 注：调用二分查找 查3
#结果为 2
def bin_search(data_set, value):
    low = 0
    high = len(data_set) - 1
    while low <= high:
        mid = (low+high)//2
        if data_set[mid] == value:
            return mid
        elif data_set[mid] > value:
            high = mid - 1
        else:
            low = mid + 1

#注：算法执行过程中 通过 left 和 right 维护候选区
#注：不管什么情况 都会是整个候选区缩小一半  最后缩小到1个或者2个
#所以 时间复杂度：O(logn)   logn 比n 小
#所以二分查找比线性查找 效率高


#10 二分查找与线性查找的比较
#写的 cal_time的模块 里面有个函数  这个函数是装饰器
import time

def cal_time(func):
    def wrapper(*args, **kwargs):
        t1 = time.time()
        result = func(*args, **kwargs)
        t2 = time.time()
        print("%s running time: %s secs." % (func.__name__, t2 - t1))
        return result

    return wrapper
#-----------------------------------------------------
from cal_time import *   # 注：导入写的模块
#注：对这2个函数加了2个装饰器
@cal_time
def linear_search(li, val):
    for ind, v in enumerate(li):
        if v == val:
            return ind
    else:
        return None

@cal_time
def binary_search(li, val):
    left = 0
    right = len(li) - 1
    while left <= right:
        mid = (left + right) // 2
        if li[mid] == val:
            return mid
        elif li[mid] > val:
            right = mid - 1
        else:
            left = mid + 1
    else:
        return None

li = list(range(10000000)) # 注：大一点的数组
linear_search(li, 38900000)
binary_search(li, 38900000)
#结果为
# 2
# linear_search running time: 0.601691722869873 secs.
# binary_search running time: 0.0 secs.

#二分查找肯定非常快  2的32次方长度的列表 最多只要查32、33次 但线性查找要查42亿次
#列表内置函数 index() 就是线性查找
#因为二分查找有个要求：列表必须是有序的列表，但是  列表不一定是有序的，它只能用线性查找
#二分查找必须先排序  排序的时间复杂度大于O(n)

#有序的用二分查找，无序 如果以后要一直查  先排序  以后直接查 (注意排序的时间复杂度)


#11 排序介绍
# 什么是列表排序
# 常⻅排序算法介绍
# 排序算法分析

# 排序：将一组“无序”的记录序列调整为“有序”的记录序列。
# 列表排序：将无序列表变为有序列表
#       输入：列表
#       输出：有序列表 升序与降序
# 升序与降序         # 注：2个基本排序方式
# 内置排序函数：sort()
#-----------------------------------------------------------
### 常见排序算法
# ·排序Low B三人组  ·排序NB三人组       ·其他排序
#   冒泡排序               快速排序               希尔排序
#   选择排序               堆排序                计数排序
#   插入排序               归并排序               基数排序


#12 冒泡排序介绍
### 冒泡排序 (Bubble Sort)
# 列表每两个相邻的数，如果前面比后面大，则交换这两个数。
# 一趟排序完成后，则无序区减少一个数，有序区增加一个数。
# 代码关键点：趟、无序区范围 (重点)

# 注：目的是为了排除来一个升序的列表

#列表     注：右边是下标
# 1   8     <-- 9 和 1比 ；9 >1  交换 9 1        9   8
# 9   7     <-- 8 和 9比 ；8 < 9 不交换          1   7    <-- 比较到倒数第二个
# 2   6     <-- 8 和 2比 ；8 > 9 交换 8 2        8   6
# 8   5     <-- 7 和 8比 ；7 < 8 不交换          2   5
# 3   4     <-- 7 和 3比 ；7 > 3 交换 7 3        7   4
# 6   3     <-- 7 和 6比 ；7 > 6 交换 7 6        3   3
# 4   2     <-- 7 和 4比 ；7 > 4 交换 7 4        6   2
# 5   1     <-- 7 和 5比 ；7 > 5 交换 4 5        4   1
# 7   0                                         5   0    <--
#这是冒泡排序的1趟  从小到上走一遍 最后箭头只会到倒数第2个元素 (因为不会往后比了)
#冒泡排序  就像烧开水  气开了一样
#这一趟下来  这1个最大的数上去了  这个位置肯定就是最后1个
#上面的叫有序区(已经排好了的)，下面的叫无序区
#第二趟只要对整个无序区进行排序，因为9已经排好了的
#第0趟有序区没有数
#第1趟有序区 9
#第2趟有序区 9 8
#第3趟有序区 9 8 7
#第4趟有序区 9 8 7 6
#第5趟有序区 9 8 7 6 5
#第6趟有序区 9 8 7 6 5 4     # 注：每一趟出来1个数 但是叫第6趟 因为从第0趟开始数的
#第7趟有序区 9 8 7 6 5 4 3
#第8趟有序区 9 8 7 6 5 4 3 2
#这1趟不用做了 9 8 7 6 5 4 3 2 1  #注：只剩下1个数的时候 不用做了

#注：整个排序算法排了 n - 1 趟
#注：循环1趟会出来1个最大的数

### 代码关键点：趟、无序区范围 (重点)
# 第0趟有序区没有数
# 第1趟有序区有1个数

#注：列表切片顾头不顾尾 n-2

# 第2趟 ；n长度 i第i趟  ；n - i；无序区还剩n - i个数
# 第2趟 n-i =9-2=7 还剩7个数 最上面那个数下标为6
# 但箭头不会指到 下标为6 那 因为后面没有数了 所有指到下标为5的数 ;n-i-1

#13 冒泡排序
import random   # 注：导入随机模块
def bubble_sort(li):    # 注：传入列表
    for i in range(len(li)-1):  # 注：整个算法排了n - 1 趟；i表示 第 i 趟 且从0开始
    #上面定义走n-1趟
        # 注：每一趟里都有1个指针，箭头永远从0开始，到 n - i -1
        for j in range(len(li)-i-1):    # 注：实际是确定的箭头    指针顾头不顾尾
        # 注：每一趟里都有1个指针，箭头永远从0开始，到 n - i -1
		# 注：想想第0趟 排n-1个数 下标n-i-2 (0,n-i-1)	这代表n-i-1个
            if li[j] > li[j+1]: # 注：箭头要和下一个元素 比较大小 如果这个数大于后边的数
            # 注：li[j]箭头那个数    li[j+1] 箭头后面那个数
                li[j], li[j+1] = li[j+1], li[j] # 注：大于就交换
                # 注：Python内部实现 实际是 元组的交换
        print(li)

# li = [random.randint(0,10000) for i in range(1000)]  # 注：列表生成式 生成长度是1000的列表
# print(li)   # 打印列表
# bubble_sort(li) # 注：调用算法
# print(li)   # 打印排序后的列表
#结果为
#[6507, 6107, 1706, 4345, 3183,…………
#[8, 10, 13, 51, 53, 53, 57, …………       # 注：升序的

li = [3,2,4,6,5,9,8,7,1]
print(li)
bubble_sort(li)
#结果为
# [3, 2, 4, 6, 5, 9, 8, 7, 1]       # 注：原来的列表
# [2, 3, 4, 5, 6, 8, 7, 1, 9]       # 9
# [2, 3, 4, 5, 6, 7, 1, 8, 9]       # 8
# [2, 3, 4, 5, 6, 1, 7, 8, 9]       # 7
# [2, 3, 4, 5, 1, 6, 7, 8, 9]       # 6
# [2, 3, 4, 1, 5, 6, 7, 8, 9]       # 5
# [2, 3, 1, 4, 5, 6, 7, 8, 9]       # 4
# [2, 1, 3, 4, 5, 6, 7, 8, 9]       # 3
# [1, 2, 3, 4, 5, 6, 7, 8, 9]       # 2     1自动最小了

### 注：如果想降序排序 小于的 上去就行了  改 if li[j] < li[j+1]:


# 时间复杂度：O(n**2)
# 注：n 是列表长度 算法里没有发生循环折半的过程 2层关于n的循环  所以复杂度O(n**2)
#####################################################################################
def bubble_sort2(li):
    for i in range(len(li)-1):
        for j in range(len(li)-i-1):
            if li[j] > li[j+1]:
                li[j], li[j+1] = li[j+1], li[j]
# 时间复杂度：O(n2)
#####################################################################################
li = [9,8,7,1,2,3,4,5,6]
print(li)
bubble_sort(li)
#结果为
# [9, 8, 7, 1, 2, 3, 4, 5, 6]
# [8, 7, 1, 2, 3, 4, 5, 6, 9]
# [7, 1, 2, 3, 4, 5, 6, 8, 9]
# [1, 2, 3, 4, 5, 6, 7, 8, 9]
# [1, 2, 3, 4, 5, 6, 7, 8, 9]   # 注：这1趟没有任何交换
# [1, 2, 3, 4, 5, 6, 7, 8, 9]
# [1, 2, 3, 4, 5, 6, 7, 8, 9]
# [1, 2, 3, 4, 5, 6, 7, 8, 9]
# [1, 2, 3, 4, 5, 6, 7, 8, 9]
####################################################################
#改善：如果在1趟过程中 没有发生交换 ，我们就认为 已经排好序了
#怎样改进？  加1个标志位  在i循环 那里 放1个标志位

# 如果冒泡排序中的一趟排序没有发生交换，则说明列表已经 有序，可以直接结束算法。

def bubble_sort_1(li):
    for i in range(len(li)-1):
        exchange = False        # 在第i趟那加标志位
        for j in range(len(li)-i-1):
            if li[j] > li[j+1]:
                li[j], li[j+1] = li[j+1], li[j]
                exchange = True # 注：如果有交换 把它识成True  交换这里也是1个标志位
        if not exchange:    # 注：如果每1趟结束后 exchange没有发生交换 (这个在for里面)
            return          # 注：就直接结束掉这个函数
#极端例子：如果传入的无序列表 是排好了的，它就只要走一趟  而原本的冒泡排序是 n - 1 趟


#14 选择排序
#先从列表中遍历1遍  可以找到最小的数  拿出来
#再把剩下的元素 再遍历1遍  可以找到第2小的数  再拿出来
#再剩下的……第3小……第4小……

### 拿出来放在哪？
#可以放在1个新列表里 (这是最简单版的)
def select_sort_simple(li):
    li_new = [] # 这里还需要1个新列表
    for i in range(len(li)):    # 注：遍历1遍出来1个数  需要遍历 n 遍
        # for j in li:    # j 就是元素/值  如果它是最小的就拿出来
        min_val = min(li)   # 注：调用内置函数
        li_new.append(min_val)  # 把最小值放到新列表里
        li.remove(min_val)  # 该值删掉
        #值重复的也没关系 ，因为它会从左边找
    return li_new   # 返回新列表

li = [3,2,4,1,5,6,8,7,9]
print(select_sort_simple(li))
#结果为 [1, 2, 3, 4, 5, 6, 7, 8, 9]
#这个算法 是 正确的 但是不推荐写  有几点致命缺点
#1、生成2个列表，数据量大，多占内存
#       冒泡排序 叫他原地排序  不需要开辟1个新的列表 在原来的列表上
#2、复杂度 不是O(n)
# min()函数 O(n)
# remove()删除函数  也是O(n)  因为列表删除1，不能只删了，删了的话会造成空位，后面都要往前挪1步，过程是O(n)
#相当于里面有2个O(n)   但是2个O(n)记为1个O(n)
# 所以时间复杂度是O(n**2) 而不是O(n**3)
###############################################################################
# 不想开辟新列表 但想把选的数放到1个地方
# 把它放到列表的第1个位置 (它只要和第一个数交换 就可以了)  接下来找无序区最小的数 再跟无序区的第1个位置交换
# 为什么不放到最后1个位置：放到最后1个位置 代码不一样
def select_sort(li):
    #还是需要n趟，每1趟出来1个最小的数
    # 但n-1趟放完后  还是1个数，那个数值最大的，所有和冒泡排序1样，需要n - 1趟
    for i in range(len(li) - 1): # i 是第几趟
        # 遍历无序区的范围
        # 第0趟从0到最后，第1趟从1到最后，第i趟从i到最后
        min_loc = i # 记最小值的位置(下标)，因为后面要做交换，记无序区的第1个数为最小值
        # for j in range(i,len(li)):  # i->列表长度 因为前包后不包所有写列表长度
        for j in range(i+1,len(li)): # 所以可以从 i + 1开始遍历
        # 没必要自己和自己比
        # j 是我们要从哪看到的
            if li[j] < li[min_loc]: # 注：如果遍历的数 比那个数还要小
                min_loc = j         # 注：就min_loc继承j ；j就是最小值的下标
                #for循环执行完了 min_loc就是无序区最小的那个数的下标了
        li[i], li[min_loc] = li[min_loc], li[i] #最小的数和无序区的第1个值交换
        # 1趟就完成了 运行 n-1趟，选出n-1个数，最后1个数 一定是最大的
        print(li)
li = [3,4,2,1,5,6,8,7,9]
print(li)
select_sort(li)
print(li)
#结果为 [1, 2, 3, 4, 5, 6, 7, 8, 9]
#结果为 先排除小的
# [3, 4, 2, 1, 5, 6, 8, 7, 9]
# [1, 4, 2, 3, 5, 6, 8, 7, 9]
# [1, 2, 4, 3, 5, 6, 8, 7, 9]
# [1, 2, 3, 4, 5, 6, 8, 7, 9]
# [1, 2, 3, 4, 5, 6, 8, 7, 9]
# [1, 2, 3, 4, 5, 6, 8, 7, 9]
# [1, 2, 3, 4, 5, 6, 8, 7, 9]
# [1, 2, 3, 4, 5, 6, 7, 8, 9]
# [1, 2, 3, 4, 5, 6, 7, 8, 9]
# [1, 2, 3, 4, 5, 6, 7, 8, 9]
###########################################################
def select_sort(li):
    for i in range(len(li) - 1):
        min_loc = i
        for j in range(i+1, len(li)):
            if li[j] < li[min_loc]:
                min_loc = j
        if min_loc != i:
            li[i], li[min_loc] = li[min_loc], li[i]

# 时间复杂度：O(n**2)
#注：代码规模是n ，没有出现折半，而且代码里没有出现任何 函数 (min\remove复杂度大于O(1)的函数)
#注：所以2层循环是O(n**2)

#它暂时没有像冒泡一样的优化；也没有二分查找优化(因为二分查找前提是有序的)，暂时没有优化
###########################################################
### 选择排序 (Select Sort)
# 一趟排序记录最小的数，放到第一个位置
# 再一趟排序记录记录列表无序区最小的数，放到第二个位置
# ……
# 算法关键点：有序区和无序区、无序区最小数的位置
# 注：更注意的是无序区的位置  记录无序区里最小数的位置(默认指定无序区里第1个数，通过比较 更新)


#15 插入排序
#原理类似于 玩牌的时候 摸1张牌 把7 插到 10 的左边

### 插入排序
# 初始时手里(有序区)只有一张牌
# 每次(从无序区)摸一张牌，插入到手里已 有牌的正确位置

### 过程
# 5 7 4 6 3 1 2 9 8
#手里的牌是5
# 摸到1张7  7插到5的右边
# 4     把4查到5的左边，把 5  7 的位置往右边挪  前面就空出1个位置  只需要拿1个变量把它存起来
# 457 6 3 1 2 9 8   ，6的话 插到5  7 中间  所有 7 往右 挪一挪
# 4567 3 1 2 9 8 ，    3的话 4567 全都挪  右边 3 插过来
# 34567 1 2 9 8 ，       1的话 34567 全都往右挪
# 134567 2 9 8 ，        2的话 34567后面5个数 挪一下 ，3插过来
# 1234567 9 8，          9   不变放在这
# 12345679 8，           8   把9挪一下，8 插过来
# 123456789

#弄清楚 哪些牌是手里的牌 ，哪些牌是摸到的牌
#摸多少次牌，就是我们要排序多少趟
#我们要摸 n - 1 次牌  (一共长度为n ，手里有1张牌 ，摸 n-1次)
#摸到4后 从右往左看  57  先7 后5  ，左边有比4小的数停掉循环，或者走到最左边的元素了 停掉循环
#从右边循环看

# 时间复杂度：O(n2)
def insert_sort(li):
    for i in range(1, len(li)):  # 最开始手里已经有1张牌
        # i 表示摸到的牌的下标
        tmp = li[i] # 注：把摸到的牌存起来 因为它要往后挪
        #这个临时变量最后才用到，就是保存li[i]的 更形象
        j = i - 1   # 注：j 指的是手里的牌的下标 (起初是最右边的牌)
        # 如果j 这个牌 比 摸到的牌 小 就把摸到的牌插到j的右边
        # 如果j已经到最左边了 j=0的时候  比手里摸到的牌i
        # 如果j大  i小(摸到的牌) 则j往右挪一个
        while j >= 0 and tmp < li[j]:   # 循环里是 数往右移，j往前看下一个 ；tmp是li[i]
        # j >= 0 表示 j到了-1退出
        # 找到1个比只要j比摸到的牌i小的情况 退出
            li[j + 1] = li[j]   # 把数往右移了 (以前都理解错了，其实右边仅仅只是个值，左边被赋值)
            #而且右边 一开始等于 j=i-1 j+1=i 的下标遍历不到的 不影响
            j = j - 1   # j 这个箭头往左移 1 个位置 ，右边仅仅是值 左边才是
        li[j + 1] = tmp # while循环结束了 li[i]摸的牌写到 j+1的位置；代表插入i的 值 在j+1
        print(li)
# while循环干的事情：找插入的那个位置
li = [3,2,4,1,5,7,9,6,8]
print(li)
insert_sort(li)
# print(li)
#结果为 [1, 2, 3, 4, 5, 6, 7, 8, 9]
#结果为
# [3, 2, 4, 1, 5, 7, 9, 6, 8]   # 注：原来的列表
# [2, 3, 4, 1, 5, 7, 9, 6, 8]   # 注：一开始有序区只有3，摸到2，把2插到3的左边 ，有序区23
# [2, 3, 4, 1, 5, 7, 9, 6, 8]   # 注：有序区23   摸到4 把4插到3右边     有序区234
# [1, 2, 3, 4, 5, 7, 9, 6, 8]   # 注：234     1       插到2的左边  1234
# [1, 2, 3, 4, 5, 7, 9, 6, 8]   # 注：1234    5       右边  12345
# [1, 2, 3, 4, 5, 7, 9, 6, 8]   # 注：12345   7       右边  123457
# [1, 2, 3, 4, 5, 7, 9, 6, 8]   # 注：123457  9       右边  1234579
# [1, 2, 3, 4, 5, 6, 7, 9, 8]   # 注：1234579 6       5后边 12345679
# [1, 2, 3, 4, 5, 6, 7, 8, 9]   # 注：12345679    8   把8插到7的右边    123456789
#注：排了8次

#while循环里 把数往右移 j往前看下一个
#每次都是写到j+1的位置

### while j >= 0 and tmp < li[j]的理解：退出循环的条件 1、2 (# 也可以单纯字面理解)
#情况1 注：j<i时 不用挪了 把i放到 j+1的位置
#情况2 注：4567  i=3  7、6、5比3大 往右移
#        4 还比3 大 往右移 j=-1了   ，即j<0时 ，while退出
#        这时  把这个元素 还是写在 j+1的位置(即0的位置)
######################################################################
import random
from cal_time import *  # 检测1个代码的运行时间，要把打印的都注释起来或去掉

@cal_time   # 注：装饰器
def insert_sort(li):
    for i in range(1, len(li)):
        tmp = li[i]
        j = i - 1
        while j >= 0 and tmp < li[j]:
            li[j + 1] = li[j]
            j = j - 1
        li[j + 1] = tmp

li = list(range(10000)) # 注：用range方法生成1个1万的列表
random.shuffle(li)      # 注：random模块的shuffle方法 打乱
insert_sort(li)
#结果为 insert_sort running time: 4.095908880233765 secs.

# 时间复杂度：O(n**2)
#不是O(n) 而是O(n**2)   ，n是代表列表长度，没有折半；2层循环，这个循环跟j相关的，j是跟n相关的
#所以j是跟n 相关的
#因为插入1个的过程的，我是要移动一些元素，并不知道移动多少元素。摸来第1张牌最多移动1个元素，摸来第2张牌最多移动2个元素，摸来第n张牌最多移动n-1个元素
#每一趟最多移动n/2个元素，n趟 (n**2)/2
######################################################################
#注：冒泡排序，选择排序，插入排序 时间复杂度都是O(n**2),而且它们3个都是原地排序

#注：O(n**2)的排序算法具体效率怎么样？
# 1台电脑1s中的运行效率在10的7次方，1000万次基本操作
# n=10000,n方式10000*10000是1亿，所以需要十秒左右

#冒泡排序的效率比较慢，平时比较效率是不太能接受的


#16 快速排序原理介绍
### 快速排序
# 快速排序：快
# 快速排序思路：
#       取一个元素p（第一个元素），使元素p归位；
#       列表被p分成两部分，左边都比p小，右边都比p大；
#       递归完成排序。

# 排序前：5 7 4 6 3 1 2 9 8      P为5
# p归位： 2 1 4 3 5 6 7 9 8      左边比5小右边比5大  #这个过程怎么实现的 后面会说
# 第3步递归完成 (5归位后 列表分为左右2部分  分别再调用)

# 2 1 4 3   5   6 7 9 8
#第1个元素2  2归位    1 (2) 4 3       小列表又被分成2部分
#左边的列表1     只有1个元素的时候  或者0个元素的时候 就达到了递归的终止条件
#               因为1个元素的时候是有序的
#右边的列表43    4归位  3 4  两个部分3(4) 左边部分1个元素3，右边0个元素(以4为分割)
#进而整个大列表的左边 都递归完成了

#   整个大列表的右边   6 7 9 8
#6归位后(6)798    左边零个元素(不用递归了)     右边7 9 8 三个元素
#7 9 8      7归位后(7)98    左边零个元素      右边9 8 两个元素  左边不用递归 递归右边
#98两个元素  9归位后   列表分为2部分8(9)     左1个元素8(递归完成)  右边0个元素(递归完成)
# 89递归完成 所以 789 递归完成  所以6789递归完成，所以右边递归完成，所以整个大列表递归完成

# 相当于把它分成类似二分整  每一个进行递归
# 只需要实现归位算法，排序只需要递归就行了
#-------------------------------------------------------------------------------------------def quick_sort(data, left, right):  # data表示列表  left、right 列表左右  表示范围
    if left < right:    # 说明列表取余至少有2个元素，有2个或者2个以上的元素 递归(递归的终止条件)
    # left <  right 列表至少2个元素
    # left == right 列表区域有1个元素
        mid = partition(data, left, right)  # 先用函数 算出递归后的下标位置
        quick_sort(data, left, mid - 1)     # 列表分成两部分，递归第1部分 (left,mid-1)
        quick_sort(data, mid + 1, right)    # 递归第2 部分   (mid+1,right)
# 归位函数时partition函数 data 参数1 是我们的列表，left和right是列表的一部分
# 比如 整个大列表 left是0的位置  right是n-1的位置
# 这个归位函数返回1个mid的值 (归位后 归位的数的下标)
# 返回了mid值后 列表可以被拆分成2部分  (left --> mid-1) (mid+1 --> right) 2部分
# 再对这2步进行递归

# 只要把partition函数写出来
#-------------------------------------------------------------------------------------------
# 5 7 4 6 3 1 2 9 8
# 注：5归位，先拿1个变量把5存起来 left=5下标  right=8下标
# 注：列表左边有1个空位  是给5小的数准备的，这个数从右边开始找
# 8 比5大 不对， 9 不对，2 放过来
# 2原来的位置 空位，从左边找比5大的数放过去
# 这个空置不能是5自己过去，因为左边要比5小 不满足
# 2原来的位置空位，从左边找比5大的数扔过去。7比5大，扔过去
# 2   4 6 3 1 7 9 8         7--》扔到右边
# 扔的过程是从left位置 到 right位置
# 左边有空位，从右边找比5小的数，1 放过来；从right位置放到left位置
# 右边有空位，1比5小 没问题，4比5小 没问题；6比5大，6去右边空位
# 左边有空位，6比5大 没问题，3比5小 去左边
# 接下来还应该从左边找比5大的数 放到右边去，但是 3 比5 大。到这里发现 left和right重合了
# left和right重合了说明 这个位置在中间，我们把5放过来 就可以


#17 快速排序代码实现
# 快速排序-partition函数
def partition(li, left, right):  #参数1列表   2、3操作的列表范围
    # 存出来第一个位置
    tmp = li[left]    # 注：目的 把p存起来。注意不要写0，切的过程应该是left的位置，而不是0的位置
    while left < right: # 注：left=right的时候结束，终止条件
        # 这是右边的
        while left < right and li[right] >= tmp:   # 从右边找比tmp小的数。
        # 如果右边都比5大 就碰上了 ，希望退出这个循环
        # left < right 检测，保证 右边一直大的情况，最后结果不是right-1这种
            right -= 1      # 只要这个数比tmp大，left向左移动1个
            # 注：往左走1步
        li[left] = li[right]    #注：如果left=right极端情况，那就自己等于自己 不影响
        #如果找到了 把right写到空位上 ，把right这个数写到left位上
        #把右边的值写到左边空位上
        # print(li)   # 注：从右边找到比5小的

        # 这是左边的
        while left < right and li[left] <= tmp: # 如果找到了，从左边找比5大的数
        # 只要左边小于等于 tmp，一直循环；一旦找到比它大的数 终止循环
        # left=right 没有找到时，检测一下 left < right 不执行left+=1
        # 只要left和right碰上就退出
            left += 1
        li[right] = li[left]    # 把左边的值写到右边空位上
        #如果找到了，把left的值 写到 右边的空位上 right
        #它们两个碰上了 也没关系 ，自己等于自己
        # print(li)   # 注：从左边找到比5大的
    # 两个小循环一直执行，不管在哪只要left和ritht等了，某个循环不执行了
    # 那么等了之后，触发外面的大条件，跳出循环。把原来的值写到空位上
    li[left] = tmp      # 把tmp归位
    return left # 返回mid的值  left和right都行，因为碰上了
    # 返回值 为的是 嵌套小循环

li = [5,7,4,6,3,1,2,9,8]
print(li)
partition(li,0,len(li)-1)
print(li)
#结果为
# [5, 7, 4, 6, 3, 1, 2, 9, 8]
# [2, 7, 4, 6, 3, 1, 2, 9, 8]
# [2, 7, 4, 6, 3, 1, 7, 9, 8]
# [2, 1, 4, 6, 3, 1, 7, 9, 8]
# [2, 1, 4, 6, 3, 6, 7, 9, 8]
# [2, 1, 4, 3, 3, 6, 7, 9, 8]
# [2, 1, 4, 3, 3, 6, 7, 9, 8]
# [2, 1, 4, 3, 5, 6, 7, 9, 8]   # 注：5归位
####################################################################
#逻辑复杂 代码对称
# 开始 tmp = li[left]
# 最后 li[left] = tmp 写出去写回来
# 中间1个大while
# 2个小while，每个while都是 1个赋值
# 开始是右边，然后是左边的。先右后左，碰头或者找到一个数，就切换循环
####################################################################
# 快速排序-partition函数
def partition(li, left, right):
    tmp = li[left]
    while left < right:
        while left < right and li[right] >= tmp: # 从右边找比tmp小的数
            right -= 1          # 往右走一步
        li[left] = li[right]    # 把右边的值写到左边空位上
        while left < right and li[left] <= tmp:
            left += 1
        li[right] = li[left]    # 把左边的值写到右边空位上
    li[left] = tmp              # 把tmp归位
    return left     # mid 是 这个函数返回left值的目的

# 快速排序-框架
def quick_sort(li, left, right):
    if left < right:    # 至少2个元素
        mid = partition(li, left, right)    # 这个函数返回left值的目的
        quick_sort(li, left, mid - 1)   # 左边部分
        quick_sort(li, mid + 1, right)  # 右边部分

li = [5,7,4,6,3,1,2,9,8]
quick_sort(li, 0, len(li)-1)
print(li)
# [1,2,3,4,5,6,7,8,9]

#新理解
li[right] = li[left]	# 注：右边仅仅是值，而左边的值的变化和下标、值 2者都有关


#18 快速排序代码实现2
### 快速排序
# 快速排序的效率：
#       快速排序的时间复杂度  O(nlogn)
# 快速排序的问题：
#       最坏情况
#       递归

##################################################################
#注：假设一开始有16个数，n=16，一次partition 把它分成2部分
                    16            partition的过程 (每1层都做了一次partition)  partition 是16   O(n)
            8                   8 partition的过程 (每1层都做了一次partition) partition 是8+8 16
      4           4       4           4   partition的过程 (每1层都做了一次partition)  是16   O(n)
2          2   2     2 ……………………                            是16   O(n)

# 1次partition的 复杂度:
# left 一边  right一般；left从右往左边撒，right从右往左边撒，最后碰上了
# 相当于 从两边 往中间  把整个列表扫描了一边，所以1个长度为n的列表，它的实际复杂度是O(n)

#每一层都是O(n)
#一共logn层  log16层
# 所以这个时间复杂度是 O(nlogn)

#装饰器不能放在递归函数上，装饰器也会递归，会打印很多次
# 解决方法：套一层马甲
import random
from cal_time import *
import copy         # copy模块做li深拷贝，为了一块执行
import sys              # 注：修改递归最大深度

sys.setrecursionlimit(10000)    # 注：修改递归最大深度

@cal_time
def bubble_sort(li):
    for i in range(len(li)-1):
        exchange = False
        for j in range(len(li)-i-1):
            if li[j] > li[j+1]:
                li[j], li[j+1] = li[j+1], li[j]
                exchange = True
        if not exchange:
            return

def partition(li, left, right):
    tmp = li[left]
    while left < right:
        while left < right and li[right] >= tmp:
            right -= 1
        li[left] = li[right]
        while left < right and li[left] <= tmp:
            left += 1
        li[right] = li[left]
    li[left] = tmp
    return left

def _quick_sort(li, left, right):   # 注：改个名
    if left < right:
        mid = partition(li, left, right)
        _quick_sort(li, left, mid - 1)
        _quick_sort(li, mid + 1, right)

@cal_time
def quick_sort(li): # 指接收1个li参数
    _quick_sort(li, 0, len(li)-1)   # 调用这个函数

li = list(range(10000))
random.shuffle(li)  # 乱序

li1 = copy.deepcopy(li)     # copy模块做li深拷贝，为了一块执行  复制成2个一样的列表
li2 = copy.deepcopy(li)     # copy模块做li深拷贝，为了一块执行  复制成2个一样的列表

quick_sort(li1)  # 快速排序 传入li1
bubble_sort(li2)    # 冒泡排序  传入li2

print(li1)
print(li2)
#结果为
# quick_sort running time: 0.02394270896911621 secs.
# bubble_sort running time: 8.118826389312744 secs.


#举例  n = 1024 时，冒泡排序 n**2 大概在100万 1024*1024
                #  快速排序 nlogn 1024*log1024 = 1024*10 = 1万
#数越大差的越多  比如 n = 2的32次方 大概42亿，冒泡排序42亿*42亿  亿亿级别
                # 快排      42亿*log42亿 = 42亿*32  也就几百亿   差很多倍
# 所以 快排的效率 比冒泡高很多
#####################################################################
# ### 快速排序
# # 快速排序的效率：
# #       快速排序的时间复杂度  O(nlogn)
# # 快速排序的问题：
# #       最坏情况
# #       递归
#
# ##################################################################
# 快排的问题存在：
# 1、递归的写法：Python有一个递归最大深度999  可以改
# 递归消耗相当一部分的系统资源 (不好的地方)
# 2、快速排序有一个最大不好的地方存在，当列表是 9 8 7 6 5 4 3 2 1 时
#       这种最坏的情况 冒泡每次至少一个数 ，而不是每次大概劈成一半，就不会出现nlogn了，复杂度是n**2
# 9,8,7,6,5,4,3,2,1
# 1,8,7,6,5,4,3,2,9     右边没有
# 1,8,7,6,5,4,3,2       左边没有
# 2,7,6,5,4,3,8         右边没有
# 2,7,6,5,4,3
# ………………

# 示例
li = list(range(10000,0,-1)) # 倒序的列表
quick_sort(li)
#结果为 RecursionError: maximum recursion depth exceeded in comparison
#达到了递归最大深度，因为每次少1个数，会递归n层，递归了1000层，超过了最大线程

#修改递归最大深度后	   sys.setrecursionlimit(100000)
#结果为 5s左右

#如何解决？随机化版本的快速排序
#随机找1个值，而不是找第1个值。把第1个数和随机选的数交换一下，再按照之前的partition函数交换一下
#只需要加一步
#这样倒序的例子，时间复杂度不会特别高，只不过还是会出现最坏情况，只不过最坏情况你不能设计出来了。最坏的情况就不需要考虑，快排没有问题

#算法有正常复杂度和最坏复杂度。最好情况时间复杂度、一般情况时间复杂度、最坏情况时间复杂度
# 一般看的是一般情况 和 最坏情况

#快速排序的最坏情况是 n**2 只不过最坏情况的可能性非常小
#快速排序一般情况是 n*logn
# 最好排序  相当于只走一次

#改进之后，冒泡的最好情况是O(n),但是最好情况只有1个，它的最好情况太少了


#19 堆排序前传树的基础知识
# 树是一种数据结构 比如：目录结构
# 树是一种可以递归定义的数据结构
# 树是由n个节点组成的集合：     #注：这是递归定义的方式，节点就是元素
#       如果n=0，那这是一棵空树；
#       如果n>0，那存在1个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身又是一棵树。

# 一些概念
#       根节点、叶子节点
#       树的深度（高度）
#       树的度
#       孩子节点/父节点 子树
#-------------------------------------------------------
#注：根节点：A
#注：叶子节点：不能分叉的节点  [最后一个，下面没有孩子了](叶子已经到了树的最末端，不能分叉)
#-------------------------------------------------------
#注：树的深度(高度)：看它最深有几层 。1层2层3层4层
#-------------------------------------------------------
#注：节点的度：F节点往下分了3个叉，度是3。分了几个叉，就有几个度  看往下的叉
#注：树的度就是整个树里 最大的那个节点的度
#注：树的度就是 这个树最多分了几叉。A分了6个叉，这个树的度就是6
#-------------------------------------------------------
#注：孩子节点/父节点：E叫做I的父节点，I叫做E的孩子节点
                   # A叫做B的父节点，B叫做A的孩子节点
                   # 树在上面的 辈分比较高，生下来孩子
#-------------------------------------------------------
#注：子树：大树里  把一个树枝掰下来，这个树枝代表很多小树杈，那么它是1棵子树


#20 堆排序前传二叉树的基础知识
# 二叉树：度不超过2的树       # 注：每个节点往下 最多分2个叉
#
# 每个节点最多有两个孩子节点
# 两个孩子节点被区分为左孩子节 点和右孩子节点
#--------------------------------------------
#注：二叉树 度不超过2的树
#注：B是A的左孩子节点，C是A的右孩子节点
#--------------------------------------------
# 满二叉树：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。
# 完全二叉树：叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。
#--------------------------------------------
#注：满二叉树：对称，每个叉 该有的都有，最后一层是满的
#注：完全二叉树：简单理解 从满二叉树 最后 拿走几个节点
#注：完全二叉树：从上到下，从左到右，顺序不少 ，最后一层从左往右  少了也没关系
#--------------------------------------------
#注：堆是特殊的完全二叉树


### 二叉树的存储方式（表示方式）
# 链式存储方式
# 顺序存储方式  #注：堆排序中讲顺序存储方式
#注：顺序存储方式  简答来说是 用列表存

#注：按树的顺序 存进去，是一一对应的
#注：写二叉树 最常见的操作：父亲找孩子，孩子找父亲。一层一层往下找，不能跳
#注：列表里父节点和孩子节点，下标的关系

### 父节点和左孩子节点的编号下标有什么关系？
# 0-1 1-3 2-5 3-7 4-9
# i → 2i+1  # 注：从父亲找左孩子
### 父节点和右孩子节点的编号下标有什么关系？
# 0-2 1-4 2-6 3-8 4-10
# i → 2i+2  # 注：从父亲找右孩子

###为什么这个结论？数学归纳法
#第1层2的0次方个节点
#第2层2的1次方个节点
#第3层2的2次方个节点

#注：假设孩子的节点是i ，那么父亲的节点是 (i-1)//2  注：这是整除
#注：比如 4-9  4-10。父节点是4 ,(9-1)//2 = 4 ,(10-1)//2 = 4

#注：可以用顺序存储方式存储二叉树，就是列表。一个一个挨个存
#注：父亲找孩子 i   2i+1   2i+2
#注：孩子找父亲 i   (i-1)//2

